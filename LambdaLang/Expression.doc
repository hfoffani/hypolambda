<ExpressionSintax>

<para>El calculador de expresiones reconoce, para los valores numéricos, los operadores
algebraicos <c>+ - * /</c>, los operadores de comparación <c>&gt; &lt; &gt;= &lt;= == !=</c>,
el operador de negación <c>not</c>, los operadores lógicos <c>and</c>, <c>or</c>.
Estos últimos dos operadores <c>and</c>, <c>or</c>, "cortocircuitan"; es decir, se evalúa
lo estrictamente necesario para satisfacer el resultado.</para>

<para>Para los valores de tipo cadena acepta <c>+ *</c>, donde la suma es la concatenación
de cadenas y la multiplicación repite el primer operando n veces, siendo n el segundo
operando. También se pueden comparar cadenas con <c>== !=</c>. Las cadenas también
se pueden evaluar por su valor de verdad, una cadena nula o una cadena vacía tiene
valor de verdad <c>falso</c>, una cadena no vacía tiene valor de verdad <c>verdadero</c>.
</para>

<para>Reconoce también los paréntesis <c>( )</c> para agrupar términos y explicitar la
precedencia en el orden de evaluación o modificarla.</para>

<para>La precedencia de los operadores solo está documentada para los operadores
algebraicos <c>* /</c> tienen precedencia sobre <c>+ -</c>. No es necesario utilizar
paréntesis para agrupar términos que usen estos operadores.</para>

<para>Las expresiones de comparación y el operador de negación devuelven 0 (cero) si
son falsas y algún valor mayor a cero en caso de ser verdaderas.</para>

<para>Una expresión condicional <c>X if CONDICION else Y</c> devolverá <c>X</c> si
<c>CONDICION</c> evalúa como verdadero o Y en el caso en que evalúe como falso (valor
de la expresión igual a cero). La sintaxis utilizada para esta construcción es igual
a la de Python (ver: <a
href="http://docs.python.org/reference/expressions.html#boolean-operations">
conditional_expression</a>). La expresión condicional sólo evalúa lo estrictamente
necesario; es decir, sólo se evalúa X (y no Y) si CONDICION es verdadero y viceversa,
sólo se evalúa Y (y no X) si CONDICION es falsa.</para>

<para>
    Syntax in BNF.
    <code>
        expression :=   list_exprs

        list_exprs :=
                        single_exp
                    |   single_exp ";" list_exprs

        single_exp :=
                        vname
                    |   constant
                    |   "(" expression ")"
                    |   variable = single_exp
                    |   lambdaexp "(" [ single_exp [ "," single_exp ... ]] ")"
                    |   condition
                    |   single_exp "*" single_exp
                    |   single_exp "/" single_exp
                    |   single_exp "+" single_exp
                    |   single_exp "-" single_exp
                    |   single_exp "if" condition "else" single_exp

        condition :=    single_exp
                    |   condition "and" condition
                    |   condition "or" condition
                    |   "not" condition
                    |   single_exp "&gt;" single_exp
                    |   single_exp "&gt;=" single_exp
                    |   single_exp "&lt;" single_exp
                    |   single_exp "&lt;=" single_exp
                    |   single_exp "==" single_exp
                    |   single_exp "!=" single_exp

        lambdaexp :=    lambda  [ "(" vname [ "," vname ... ] ")" ] ":" single_exp
    </code>
</para>

<para>Restricciones a tener en cuenta:</para>

<list type="bullet">
   <item>
      <description>Las expresiones pueden ser numéricas del tipo <see cref="System.Double"/>
      o de cadena <see cref="System.String"/></description>
   </item>
   <item>
      <description>Por compatibilidad hacia atrás, <see cref="Expression.Calculate"/> siempre
      devuelve un número. Si quiere que la expresión pueda devolver un
      <see cref="System.String"/> utilice <see cref="Expression.Solve"/> que devuelve
      cualquiera de los dos tipos.</description>
   </item>
   <item>
      <description>Las expresiones de comparación dan como
      resultado un número, 0 (cero) si es falso, algún número mayor que 0 (cero) en
      caso de ser verdadero.</description>
   </item>
   <item>
      <description>Las precedencias de los operadores que no están documentadas pueden variar
      en un futuro por lo que no recomendamos depender de ellas porque el resultado del cálculo
      podría variar con una nueva versión del programa. En estos casos el usuario debería utilizar
      los paréntesis para agrupar términos.</description>
   </item>
</list>

<example>
Algunos ejemplos en Python de expresiones permitidas con los resultados de la evaluación:
<code>
&gt;&gt;&gt; import ECC.Lib
&gt;&gt;&gt;
&gt;&gt;&gt; expr = ECC.Lib.Expression()
&gt;&gt;&gt;
&gt;&gt;&gt; expr.SetExpression("(2 + 3) * 2")
&gt;&gt;&gt; expr.Calculate()
10.0
&gt;&gt;&gt; expr.SetExpression("(2 &gt; 3) or (3 &gt; 2)")
&gt;&gt;&gt; expr.Calculate()
1.0
&gt;&gt;&gt; expr.SetExpression("(2 &gt; 3) and (3 &gt; 2)")
&gt;&gt;&gt; expr.Calculate()
0.0
&gt;&gt;&gt;
&gt;&gt;&gt; expr.SetExpression("10 if (3 &gt; 2) else 5")
&gt;&gt;&gt; expr.Calculate()
10.0
&gt;&gt;&gt;
&gt;&gt;&gt; expr.SetExpression("10 if (3 &lt; 2) else 5")
&gt;&gt;&gt; expr.Calculate()
5.0
&gt;&gt;&gt;
&gt;&gt;&gt; expr = ECC.Lib.Expression("(10 if (3 &gt; 2) else 5) / 5")
&gt;&gt;&gt; expr.Calculate()
2.0
&gt;&gt;&gt;
&gt;&gt;&gt; expr = ECC.Lib.Expression("10 if ((not(3 &gt; 2)) else 5")
&gt;&gt;&gt; expr.Calculate()
5.0
&gt;&gt;&gt;
&gt;&gt;&gt; expr = ECC.Lib.Expression(" \"A\" + \"B\" ")
&gt;&gt;&gt; expr.Solve()
"AB"
&gt;&gt;&gt;
&gt;&gt;&gt; expr = ECC.Lib.Expression("""
... f = lambda x:
...     (x*f(x-1)) if x > 1 else 1;
... f(4)
""")
&gt;&gt;&gt; expr.Calculate()
24.0
&gt;&gt;&gt;
</code>
También es posible usar variables en la fórmula. La clase permite cambiar el objeto
enlazado y volver a recalcular el nuevo resultado reusando la fórmula previamente
definida.
<code>
&gt;&gt;&gt; material = ECC.Data.Material()
&gt;&gt;&gt;
&gt;&gt;&gt; material.UserNumber5 = 100.0
&gt;&gt;&gt; material.UserNumber8 = 200.0
&gt;&gt;&gt;
&gt;&gt;&gt; expr.SetExpression("this.UserNumber5 + this.UserNumber8")
&gt;&gt;&gt; expr.SymbolTable["this"] = material
&gt;&gt;&gt; expr.Calculate()
300.0
&gt;&gt;&gt;
&gt;&gt;&gt; material.UserNumber8 = 50.0
&gt;&gt;&gt; expr.Calculate()
150.0
&gt;&gt;&gt;
</code>
La evaluación mínima de <c>if</c>/<c>else</c> hace que en este ejemplo la parte
del <c>else</c> no se evalúe y no de error.
<code>
&gt;&gt;&gt; material = ECC.Data.Material()
&gt;&gt;&gt;
&gt;&gt;&gt; material.UserString5 = "AAA"
&gt;&gt;&gt;
&gt;&gt;&gt; expr.SetExpression("1 if this.UserString5 else 1/this.UserString5")
&gt;&gt;&gt; expr.SymbolTable["this"] = material
&gt;&gt;&gt; expr.Calculate()
1.0
&gt;&gt;&gt;
</code>
Use la propiedad de "corto-circuitar" expresiones del <c>and</c>/<c>or</c> para
controlar el valor de nulos o ceros en alguna expresión y así evitar errores en la ejecución.
<code>
&gt;&gt;&gt; material = ECC.Data.Material()
&gt;&gt;&gt;
&gt;&gt;&gt; material.UserNumber5 = 5.0
&gt;&gt;&gt;
&gt;&gt;&gt; expr.SetExpression("this.UserNumber5 and (10 / this.UserNumber5) > 0")
&gt;&gt;&gt; expr.SymbolTable["this"] = material
&gt;&gt;&gt; expr.Calculate()
1.0
&gt;&gt;&gt;
&gt;&gt;&gt; material.UserNumber5 = 0.0
&gt;&gt;&gt; expr.Calculate()
0.0
&gt;&gt;&gt;
</code>
</example>
</ExpressionSintax>